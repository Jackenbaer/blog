---
layout: post
title:  "Monero"
date:   2022-11-09 16:16:23 +0200
categories: monero 
---


# Overview
This series is for the user who wants to understand monero at a deeper level. Maybe it is somehow located between *[Zero to Monero: Second Edition](https://www.getmonero.org/library/Zero-to-Monero-2-0-0.pdf)* and the C++ *[source code](https://github.com/monero-project/monero)*.  


---
# Table of Contents
- [Resources] (#resources)
- [Address] (#address)
- [Stealth Address] (#stealth_address)
- [Key Image] (#keyimage)


---
<a name="address"></a>
# Address
```
def calc_address(A: bytes, B: bytes):
    """
    Args:
        A: bytes; public view key
        B: bytes; public spend key 
    """
    prefix = 18 
    data = bytearray([prefix]) + A + B
    checksum = keccak_256(data).digest()[:4]
    return base58.encode(hexlify(data + checksum))
```

---
<a name="stealth_address"></a>
# Stealth address ?
## Description

## Code 
```
def check_stealth_address(stealth_address: str, R: bytes, a: bytes, B: bytes, i: int)  :
    """ Checks if stealth address belongs to own private keys

    Keep in mind that R = rG and A = aG. Using R you are able to generate aR = arG = rA.

    Args:
        stealth_address: string; Stealth address to test
        R: bytes; Transaction public key (rG). Stored in field extra[1:33]).hex(). 
        a: bytes; Private view key
        B: bytes: Public spend key
        i: int; output index

    Returns:
        True if this is a received payment and the stealth address belongs to own private keys
        False if this is a foreign address

    """


    arG = ed25519.encodepoint(ed25519.scalarmult(ed25519.decodepoint(R), ed25519.decodeint(a)))

    arG =  ed25519.encodepoint(ed25519.scalarmult(ed25519.decodepoint(arG),  8 )) # There is a mathematical reason for this...
    arG += bytes([i])
    
    Hs = keccak_256(arG).digest()

    Hs = sc_reduce32(Hs)
    HsG = ed25519.publickey(Hs)

    my_addr =  ed25519.encodepoint(ed25519.edwards(ed25519.decodepoint(HsG), ed25519.decodepoint(B))).hex()

    return my_addr == stealth_address
```



```
def calc_stealth_address(r: bytes, A: bytes , B: bytes, i: int)-> str:
    """ Calculates stealth address in the form P = Hs(rA)G + B.
    
    Be careful, index and respent output (here you have to use your own public keys) have to match

    Args:
        r: bytes ; Transaction secret key (ephemeral random)
        A: bytes; pyblic view key
        B: bytes; public spend key
        i: int; output index 

    Returns:
        stealth address; subaddresses are prefixed with '8', addresses are prefixec with '4'
    """


    rA  = ed25519.encodepoint(ed25519.scalarmult(ed25519.decodepoint(A), ed25519.decodeint(r)))


    rA =  ed25519.encodepoint(ed25519.scalarmult(ed25519.decodepoint(rA), 8 )) # There is a mathematical reason for this...
    rA += bytes([i])


    Hs = keccak_256(rA).digest() # Hs stands for Hash to scalar, interpret result as scalar


    Hs = sc_reduce32(Hs)

    HsG = ed25519.publickey(Hs)

    return ed25519.encodepoint(ed25519.edwards(ed25519.decodepoint(HsG), ed25519.decodepoint(B))).hex()
```


---
<a name="resources"></a>
# Key Image 
```
def calc_key_image(a: bytes, b: bytes, R: bytes, i:int) -> bytes:
    """Calculate key image for input 

    Args:
        a: bytes; Private view key
        b: bytes; Private spend key 
        R: bytes; Transaction public key (rG) of refferenced output transaction. Stored in field extra[1:33]).hex(). 
        i: int; output index of refferenced output

    Returns:
        Key image : string
    """
    
    # x = H_s(aR) + b
    aR = ed25519.encodepoint(ed25519.scalarmult(ed25519.decodepoint(R), ed25519.decodeint(a)))
    aR =  ed25519.encodepoint(ed25519.scalarmult(ed25519.decodepoint(aR),  8 )) # There is a mathematical reason for this...
    aR += bytes([i])

    Hs = keccak_256(aR).digest()

    Hs = sc_reduce32(Hs)

    x = int.from_bytes(Hs, byteorder='little') + int.from_bytes(b, byteorder='little')

    x = x % ed25519.l
    x = x.to_bytes(32, 'little')    
    

    # P = xG
    P = ed25519.publickey(x)
    print("P = " , P.hex())



    Hp = hashToPointCN(P)



    # I = xHp(P)
    I = ed25519.encodepoint(ed25519.scalarmult(Hp, ed25519.decodeint(x)))
    return I
```

---
<a name="resources"></a>
# Resources 
| Link | Description | 
|:--|:--|
| [Official Project site](https://www.getmonero.org) | Research resources, Downloads and multiple information |
| [Source Code](https://github.com/monero-project/monero) | Source code for a monero node |
| [Zero to Monero: First Edition ](https://www.getmonero.org/library/Zero-to-Monero-1-0-0.pdf) | Detailed explanation of Monero (deprecated) |
| [Zero to Monero: Second Edition](https://www.getmonero.org/library/Zero-to-Monero-2-0-0.pdf) | Detailed explanation of Monero |
| [Blockexplorer](https://xmrchain.net) | Minimalistic but very functional blockexplorer |
| [Breaking Monero Playlist](https://www.youtube.com/playlist?list=PLsSYUeVwrHBnAUre2G_LYDsdo-tD0ov-y) | Good playlist about Monero weaknesses with Sarang Noether himself |
